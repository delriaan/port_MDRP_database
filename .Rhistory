.libPaths(data.table::last(.libPaths()[which(grepl("Program", .libPaths()))]));
options(future.globals.maxSize = params$future.globals.maxSize);
library(book.of.workflow)
params[c("req_libs", "opt_libs", "git_libs")] |> purrr::walk(~if (!rlang::is_empty(.x)) load_unloaded(!!!.x))
if ("doFuture" %in% loadedNamespaces()) registerDoFuture();
if (!any(stringi::stri_detect_fixed("workflow", search()))) { attach(new.env(), name = "workflow"); }
if (hasName(globalenv(), ".is_remote")){ rm(.is_remote)}
(as.environment("workflow")) %$% { .is_interactive <- interactive()}
library(book.of.workflow)
params[c("req_libs", "opt_libs", "git_libs")] |> purrr::walk(~if (!rlang::is_empty(.x)) load_unloaded(!!!.x))
if ("doFuture" %in% loadedNamespaces()) registerDoFuture();
if (!any(stringi::stri_detect_fixed("workflow", search()))) { attach(new.env(), name = "workflow"); }
if (hasName(globalenv(), ".is_remote")){ rm(.is_remote)}
(as.environment("workflow")) %$% { .is_interactive <- interactive()}
(as.environment("workflow"))
params[c("req_libs", "opt_libs", "git_libs")]
params[c("req_libs", "opt_libs", "git_libs")] |> purrr::walk(\(x) if (!rlang::is_empty(x)) load_unloaded(!!!x))
params[c("req_libs", "opt_libs", "git_libs")] |> purrr::walk(\(x) if (!rlang::is_empty(x[[1]])) load_unloaded(!!!x[[1]]))
params[c("req_libs", "opt_libs", "git_libs")] |> purrr::compact() |> purrr::walk(\(x) print(x))
params[c("req_libs", "opt_libs", "git_libs")] |> purrr::compact() |> purrr::walk(\(x) load_unloaded(!!!x))
params[c("req_libs", "opt_libs", "git_libs")] |> purrr::compact() |> purrr::walk(\(x) load_unloaded(!!!rlang::syms(x)))
params[c("req_libs", "opt_libs", "git_libs")] |> purrr::compact() |> purrr::map(\(x) rlang::syms(x))
params[c("req_libs", "opt_libs", "git_libs")] |> purrr::compact() |> purrr::map(\(x) rlang::expr(!!!rlang::syms(x)))
params[c("req_libs", "opt_libs", "git_libs")] |> purrr::compact() |> purrr::walk(\(x) load_unloaded(libs = x))
.libPaths(data.table::last(.libPaths()[which(grepl("Program", .libPaths()))]));
options(future.globals.maxSize = params$future.globals.maxSize);
library(book.of.workflow)
params[c("req_libs", "opt_libs", "git_libs")] |> purrr::compact() |> purrr::walk(\(x) load_unloaded(libs = x))
if ("doFuture" %in% loadedNamespaces()) registerDoFuture();
if (!any(stringi::stri_detect_fixed("workflow", search()))) { attach(new.env(), name = "workflow"); }
if (hasName(globalenv(), ".is_remote")){ rm(.is_remote)}
(as.environment("workflow")) %$% { .is_interactive <- interactive()}
params[c("req_libs", "opt_libs", "git_libs")] |> purrr::compact() |> purrr::map(\(x) rlang::expr(load_unloaded(libs = !!x)))
params[c("req_libs", "opt_libs", "git_libs")] |> purrr::compact() |> purrr::map(\(x) rlang::expr(load_unloaded(libs = !!rlang::syms(x))))
params[c("req_libs", "opt_libs", "git_libs")] |> purrr::compact() |> purrr::map(\(x) rlang::expr(load_unloaded(!!rlang::syms(x))))
params[c("req_libs", "opt_libs", "git_libs")] |> purrr::compact() |> purrr::map(\(x) rlang::expr(load_unloaded(!!!rlang::syms(x))))
params[c("req_libs", "opt_libs", "git_libs")] |> purrr::compact() |> purrr::map(\(x) rlang::expr(load_unloaded(!!!rlang::syms(x))) |> eval())
load_unloaded(book.of.utilities, book.of.features, book.of.workflow,
smart.data, DBOE, event.vectors, architect)
load_unloaded(list(DBI, magrittr, docstring, plotly, stringi,
openxlsx, lubridate, askpass, keyring, xml2, httr, jsonlite,
lexicon, cachem, memoise, furrr, doFuture, future.callr,
tictoc))
params[c("req_libs", "opt_libs", "git_libs")] |> purrr::compact() |> purrr::walk(\(x) walk(x, \(i) library(i, character.only = TRUE)))
params[c("req_libs", "opt_libs", "git_libs")] |> purrr::compact() |> purrr::walk(\(x) purrr::walk(x, \(i) library(i, character.only = TRUE)))
if ("doFuture" %in% loadedNamespaces()) registerDoFuture();
if (!any(stringi::stri_detect_fixed("workflow", search()))) { attach(new.env(), name = "workflow"); }
if (hasName(globalenv(), ".is_remote")){ rm(.is_remote)}
(as.environment("workflow")) %$% { .is_interactive <- interactive()}
makeActiveBinding(".is_remote", function(){
exists(".pbd_env") & grepl(pattern = "itdhpc", x = Sys.getenv("COMPUTERNAME"), ignore.case = TRUE)
}, env = as.environment("workflow"));
if (.is_interactive){
message("Interactive session detected ...")
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
} else { message("Non-interactive session detected ...")}
message(paste0("Current working directory is", getwd()))
.file_root <- getwd()
.image_file_root <- paste(.file_root, params$sub_dirs$data, "/")
c("99. SANDBOX") |> walk(\(x){
if (file.exists(paste0(.file_root, "/", x, ".R"))){
cat(sprintf("%s exists: skipping", x), sep = "\n")
} else {
cat(sprintf("Creating %s ...", x), sep = "\n")
cat(paste0("# ", x), file = paste0(.file_root, "/",  x, ".R"), append = FALSE)
}
})
params[c("req_libs", "opt_libs", "git_libs")] |>
purrr::compact() |> purrr::walk(\(x) purrr::walk(x, \(i) library(i, character.only = TRUE)))
install.packages("openxlsx")
install.packages("openxlsx", dependencies = TRUE)
.libPaths(data.table::last(.libPaths()[which(grepl("Program", .libPaths()))]));
options(future.globals.maxSize = params$future.globals.maxSize);
library(book.of.workflow)
params[c("req_libs", "opt_libs", "git_libs")] |>
purrr::compact() |> purrr::walk(\(x) purrr::walk(x, \(i) library(i, character.only = TRUE)))
