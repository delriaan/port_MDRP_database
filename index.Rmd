---
title: "Medicaid Drug Rebate Program (MDRP) Database"
output: 
  html_notebook:
    code_folding: hide
params:
  data_dir: data
  cran_libs: !r c('purrr', 'jsonlite', 'httr', 'summarytools', 'munsell', 'cachem', 'SmartEDA', 'htmltools', 'slider', 'stringi', 'magrittr', 'plotly', 'DT', 'data.table', 'pdftools', 'lubridate', 'future', 'furrr', 'future.callr')
  git_libs: !r paste0('book.of.', c('utilities', 'features', 'workflow')) |> c('architect')
---

```{r setup ,echo=FALSE, warning=FALSE, message=FALSE}
source("setup.R", local = TRUE)
```

#  {.tabset .tabset-fade .tabset-pills}

## Purpose &<br> Project Metadata 

This project explores the Medicaid Drug Rebate Program (MDRP) database via [API](https://data.medicaid.gov/dataset/0ad65fe5-3ad3-5d79-a3f9-7893ded7963a) calls (description [here](https://www.medicaid.gov/medicaid/prescription-drugs/medicaid-drug-rebate-program/medicaid-drug-rebate-program-data/index.html)):

```{r URLs, echo=FALSE}
urls$data
```

### Required LIbraries

```{r, echo=FALSE, cache=TRUE, cache.lazy=TRUE}
tags$table(
  style = "width:600px; "
  , tags$tr(
      tags$th(style = "text-align:middle; border: solid 2px #AAAAFF; background-color:#EEEEEE; ", "CRAN", colspan = 3, width="65%")
      , tags$th(style = "text-align:middle; border: solid 2px #AAAAFF; background-color:#AAAAAA; ", width = "*", "GitHub")
      )
  , tags$tr(
      style = "align:top"
      , slider::slide(
          params$cran_libs
          , .after = 5
          , .step = 6
          , .f = \(x){ 
              sprintf("<li>%s</li>", x) |> HTML() |> 
                tags$ul() |> 
                tags$td(style = "text-align:middle; background-color:#AAAAAA; ")
              }
          , .complete = TRUE) |> 
          purrr::compact()
      , tags$td(style = "background-color:#EEEEEE; padding-right:20px; ", urls$git_libs)
      )
  ) |> tags$p()
```

## Data <br>Wrangling 

### Retrieve and Prepare Data {.tabset}

The data were retrieved via R package [httr](https://httr.r-lib.org) with some initial conversion to [data.table](https://rdatatable.gitlab.io/data.table/) objects.  

```{r RETRIEVE_DATA, cache=TRUE,cache.lazy=TRUE, warning=FALSE, message=FALSE}
# MDRP database data
if (rlang::is_empty(dir(params$data_dir, pattern = "api_data[.][Rr]data$"))){
  if (!"api_data" %in% ls()){ 
    api_data <- urls$data |> 
      as.character() |> 
      stri_extract_all_regex("http.+csv", simplify = TRUE) |> 
      as.vector() |>
      GET() |>
      content() |>
      rawToChar() |>
      (\(x) read.csv(text = x, ))() |>
      as.data.table(na.rm = FALSE) |> 
      modify_at(c(4:7), as.character) %>% 
      modify_at(ls(., pattern = "Date"), lubridate::mdy) %>% 
      setnames(stri_replace_all_fixed(names(.) |> tolower(), ".", "_"))
  }
  
  if (!"api_dictionary" %in% ls()){ 
    api_dictionary <- invisible(urls$data |> 
      as.character() |> 
      stri_extract_all_regex("http.+pdf", simplify = TRUE) |> 
      as.vector() |>
      GET() |>
      content() |> 
      pdf_text())
    
    .summary_labels <- names(api_data) |> 
        rlang::set_names() |>
        map_chr(\(x) stri_replace_all_fixed(x, ".", " ", vectorize_all = FALSE)) |>
        imap_chr(\(x, y){ 
          api_dictionary |> 
            stri_extract_all_regex(
              sprintf(
                fmt = "(%s)[:]\n.+"
                , stri_replace_all_fixed(
                    x
                    , c("Pkg"
                        , "Intro"
                        , "COD Status"
                        , "FDA Application Number"
                        , "FDA Therapeutic Equivalence Code"
                        )
                    , c("Package"
                        , "Intro."
                        , "Covered Outpatient Drug [(]COD[)] Status"
                        , "FDA Application Number/OTC Monograph Number"
                        , "TEC"
                        )
                    , vectorize_all = FALSE
                    )
                )
              , simplify = TRUE
              ) |>
            stats::na.omit() |>
            as.vector() |>
            discard(\(x) x == "") %>%
            (\(i){ 
              .out <- ifelse(identical(character(), i), y, paste(i, collapse = "\n"))
              ifelse(stri_length(.out) > 50, paste0(.out, " ..."), .out)
            })()
        });
    
    iwalk(.summary_labels, \(x, y){ 
      .label = x; 
      api_data <<- modify_at(api_data, y, \(i){ attr(i, "label") <- .label; i }) 
    })
  }
} else { 
  if (!"api_data" %in% ls()){ 
    dir(params$data_dir, pattern = "api_data[.][Rr]data$", full.names = TRUE) |> load() 
  }
}

# openFDA supplementary data
if (rlang::is_empty(dir(params$data_dir, pattern = "openFDA_ndc[.][Rr]data$"))){
  if (!"openFDA_ndc" %in% ls()){ openFDA_ndc <- (\(x){ 
      json.file <- "drug-ndc-0001-of-0001.json";
    
      if (!json.file %in% dir()){ 
        tags$p(sprintf("Retrieve data from '%s'", urls$openFDA)) |> print()
        
        GET(urls$openFDA, write_disk(x, TRUE)) 
        unzip(zipfile = x)
      }
      
      read_json(path = json.file);
    })("ndc_json.zip") |> (\(x){
      data.table::rbindlist(modify_at(x$results, 1:length(x$results), as.data.table), fill = TRUE) |>
        setattr("metadata", x$meta)
    })()
  }
} else { 
  if (!"openFDA_ndc" %in% ls()){ 
    dir(params$data_dir, pattern = "openFDA_ndc", full.names = TRUE) |> load() 
  }
}
```

NDC sequences come in a various formats, usually a `4-4-x`, `5-4-x`, or `5-3-x` sequence (each integer indicating string length).  Sometimes other formats arise, so normalizing all NDC sequences is a good idea, especially when there is a desire (or need) to join different data containing intersecting NDCs.

#### NDC Format Inspection

The following shows proportional representation of NDC formats in the *OpenFDA* and *MDRP* data, respectively:

```{r NDC_FORMATS, echo=FALSE, warning=FALSE, message=FALSE}
list(
  `OpenFDA: NDC Formats` = openFDA_ndc[, unique(product_ndc)] |> 
      sort() |> 
      stri_split_fixed("-") |> 
      map_chr(\(x) stri_length(x) |> paste(collapse = "-")) |> 
      freduce(list(sort, table, as.data.table, \(x) setnames(x, c("NDC.Format", "N")))) 
  , `MDRP: NDC Formats` = api_data[, paste(stri_length(labeler_code), stri_length(product_code), sep = "-")] |>
        freduce(list(sort, table, as.data.table, \(x) setnames(x, c("NDC.Format", "N")) |> setkey(N))) |>
        define(
          NDC.Format = ifelse(ratio(N, type = "pareto", decimals = 6) < 0.1, "Other<br><sup>%s formats</sup>", NDC.Format) %>%
            modify_at(
              .at = which(grepl("Other", .))
              , .f = \(x) sprintf(x, sum(grepl("Other", .)))
              )
          , N = sum(N) ~ NDC.Format
          ) 
  ) |> 
  imap(\(x, y){
    plot_ly(  
      data = x
      , type = "pie"
      , labels = ~NDC.Format
      , values = ~N
      , hole = 0.6
      , width = 500
      , height = 450
      , rotation = ifelse(grepl("MDRP", y), 33, 0)
      , name = NULL
      , textinfo='label+percent'
      , insidetextorientation='radial'
      ) |>
      add_text(x = 0.5, y = 0.5
               , xref = "paper", yref = "paper"
               , text = ifelse(grepl("MDRP", y), "MDRP", "OpenFDA")
               , font = list(family = "Georgia", size = 22)) |>
      plotly::layout(
        xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE)
        , yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE)
        ) |>
      plotly::config(displayModeBar= FALSE) |>
      tags$td()
  }) |>
  tags$tr() |>
  tags$table()
```

The MDRP has many more NDC sequences due to truncation of leading zeroes.  Fortunately, an NDC sequence is a collection of code segments (present in the data) concatenated with a hyphen.  Knowing this, A function (`check_ndc_format()`) was created in order to derive conformed NDC segment sequences (using labeler and product codes) based on the OpenFDA sequences, allowing the MDRP and OpenFDA data to be joined later in the process.


```{r}
check_ndc_format <- \(lc, pc){ 
  pc <- modify_if(pc, \(i) stri_length(i) < 3, \(i) stri_pad_left(i, width = 3, pad = "0"))
  lc <- modify_if(
          lc
          , \(i) stri_length(i) < 4
          , \(i) stri_pad_left(i, width = ifelse(stri_length(pc) == 3, 5, 4), pad = "0")
          )
  paste(lc, pc, sep = "-")
}
```

#### Joined Data

The OpenFDA and MDRP data were joined using the conformed NDC sequence in the previous subsection to create  `master_drug_data` (sampled below): 

```{r JOIN_DRUG_DATA, warning=FALSE, message=FALSE}
if (rlang::is_empty(dir(params$data_dir, pattern = "master_drug_data[.][Rr]data$"))){
  if (!"master_drug_data" %in% ls()){
    master_drug_data <- (\(x, i){
      x[i, on = "alt_ndc==product_ndc"
        , nomatch = 0
        , allow.cartesian = TRUE
        , `:=`(pharm_class = pharm_class
               , dea_schedule = dea_schedule
               , product_type = product_type
               , route = route
               , marketing_category = marketing_category
               )
        , by = .EACHI
        ]
      })(api_data[, alt_ndc := map2_chr(labeler_code, product_code, check_ndc_format)], openFDA_ndc)[, `:=`(
      pharm_class := map_chr(pharm_class, \(x) unlist(x) %||% "~")
      , route := map_chr(route, \(x) unlist(x) %||% "~")
      )]
  }
} else {
  if (!"master_drug_data" %in% ls()){ 
    dir(params$data_dir, pattern = "master_drug_data[.][Rr]data$", full.names = TRUE) |> load()
  }
}
```

```{r MASTER_DRUG_DATA_SAMPLE, echo=FALSE, warning=FALSE, message=FALSE}
define(
  master_drug_data
  , .SD[!duplicated(ndc)][sample(.N, min(c(.N, 3))), ndc:marketing_category] ~ route + pharm_class
  , filter(unique(.SD), pharm_class %in% sample(unique(pharm_class), 20))
  ) |>
  setorder(route, pharm_class, alt_ndc) %>%
  setcolorder(c("ndc", "alt_ndc", "fda_product_name", keep(names(.), \(x) grepl("date", x)))) %>%
  setnames(stri_split_fixed(names(.), "_", simplify = FALSE) |> map_chr(\(x) paste(x, collapse = "<br>"))) %>% 
  DT::datatable(
    escape = FALSE
    , caption = HTML("<h3 style = 'font-family:Georgia'>Sample of <code>master_drug_data</code></h3>")
    , rownames = FALSE
    , extensions = c("Responsive", "Scroller", "RowGroup")
    , options = list(
        dom = "<ti>"
        , deferRender = TRUE
        , scroller = TRUE
        , scrollY = 600
        , rowGroup = list(dataSrc = which(grepl("route|(pharm.+class)", names(.))) - 1)
        )
  )
```

`r if ("api_data" %in% ls()){ rm(api_data) }`

## Temporal<br>Analysis 

`master_drug_data` is a great dataset for constructing simple, time-based metrics.  Given the natural order of the types of events, it is easy to setup  event sequence metrics using package [`lubridate`](https://rdocumentation.org/packages/lubridate/versions/1.9.2). The metrics created are described below:

```{r NDC_EVENTS_METRICS, echo=FALSE, warning=FALSE, message=FALSE}
.ndc_events_meta <- rlang::set_names(
    c("Days between approval \nand market release"
        , "Days active on market"
        , "Days most-recently \nabsent from market")
    , c("days_to_market", "on_market_age", "days_market_absent")
    );

append(list(`Metric Name` = "Description"), .ndc_events_meta) |> 
  imap(\(x, y) 
    if (grepl("Metric", y)){ 
      tags$tr(
        tags$th(style = "background-color: #EEEEEE; padding:2px; ", y)
        , tags$th(style = "background-color: #EEEEEE; padding-left: 5px; ", x)
        )
      } else { 
      tags$tr(
        tags$td(style = "font-weight:bold; padding:2px; text-align:right; ", y)
        , tags$td(style = "padding-left: 5px; ", x)
        )
      }
    ) |> 
  tags$table() |>
  tags$p()
```

```{r NDC_EVENTS, echo = FALSE, warning=FALSE, message=FALSE}
if (rlang::is_empty(dir(params$data_dir, pattern = "ndc_events[.][Rr]data$"))){ 
  if (!"ndc_events" %in% ls()){
    ndc_events <- master_drug_data |>
      define(
        ~alt_ndc + fda_application_number + fda_approval_date + market_date + termination_date + reactivation_date
        , days_to_market = market_date - fda_approval_date
        , on_market_age = 
            map2_dbl(ifelse(is.na(termination_date), today(), termination_date), reactivation_date, \(x, y) max(c(x, y), na.rm = TRUE)) -
            map2_dbl(ifelse(is.na(termination_date), market_date, termination_date), reactivation_date, \(x, y) max(c(x, y), na.rm = TRUE)) 
        , days_market_absent = 
            ifelse(is.na(reactivation_date), today(), reactivation_date) - 
            ifelse(is.na(termination_date), today(), termination_date)
        , unique(.SD)
        );

  
  iwalk(.ndc_events_meta, \(x, y) rlang::parse_expr(sprintf("setattr(ndc_events$%s, \"label\", \"%s\")", y, x)) |> eval(envir = .GlobalEnv))
  }
} else {
  if (!"ndc_events" %in% ls()){ 
    dir(params$data_dir, pattern = "ndc_events[.][Rr]data$", full.names = TRUE) |> load()
  }
}
```

Let us briefly explore `ndc_events`:

```{r}
(\(x, i, by){
  i <- define(x[i, on = by, allow.cartesian = TRUE]) 
  imap(.ndc_events_meta, \(x, y){
    rlang::inject(descr(x = modify_at(i, y, \(j) as.numeric(j, units = "days")), var = !!rlang::sym(y), transpose = !TRUE)) |> 
      view(method = "render") |>
      tags$td(style="width:300px; ")
  })
})(master_drug_data, ndc_events, c("alt_ndc", "fda_application_number")) |>
  tags$tr() |>
  tags$table()
```

```{r SAVE_DATA, echo=FALSE, include=FALSE, warning=FALSE, message=FALSE}
  book.of.workflow::save_image("openFDA_ndc", file.name = "openFDA_ndc"
                               , use.prefix = FALSE, use.timestamp = FALSE, safe = FALSE)
  
  book.of.workflow::save_image("api_data", "api_dictionary", file.name = "mdrp_api_data"
                               , use.prefix = FALSE, use.timestamp = FALSE, safe = FALSE)
  
  book.of.workflow::save_image("master_drug_data", file.name = "master_drug_data"
                               , use.prefix = FALSE, use.timestamp = FALSE, safe = FALSE)
  
  book.of.workflow::save_image("ndc_events", file.name = "ndc_events"
                               , use.prefix = FALSE, use.timestamp = FALSE, safe = FALSE)

```
