---
title: "Medicaid Drug Rebate Program (MDRP) Database"
output: 
  html_notebook:
    code_folding: hide
    css: markdown.css
params:
  data_dir: data
  cran_libs: !r c('purrr', 'jsonlite', 'httr', 'summarytools', 'munsell', 'cachem', 'SmartEDA', 'htmltools', 'slider', 'stringi', 'magrittr', 'plotly', 'DT', 'data.table', 'pdftools', 'lubridate', 'future', 'furrr', 'future.callr')
  git_libs: !r paste0('book.of.', c('utilities', 'features', 'workflow')) |> c('architect')
---

```{r setup, echo=FALSE, warning=FALSE, message=FALSE} 
knitr::opts_chunk$set(opts_chunk = list(cache=TRUE, cache.lazy=TRUE, warning=FALSE, message=FALSE))
source("setup.R", local = TRUE)
```

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

#  {.tabset .tabset-fade .tabset-pills}

## Purpose &<br> Project Metadata 

This project explores the Medicaid Drug Rebate Program (MDRP) database via [API](https://data.medicaid.gov/dataset/0ad65fe5-3ad3-5d79-a3f9-7893ded7963a) calls (description [here](https://www.medicaid.gov/medicaid/prescription-drugs/medicaid-drug-rebate-program/medicaid-drug-rebate-program-data/index.html)):

```{r URLs, echo=FALSE}
urls$data
```

### Required LIbraries

```{r, echo=FALSE}
tags$table(
  style = "width:600px; "
  , tags$tr(
      tags$th(style = "text-align:middle; border: solid 2px #AAAAFF; background-color:#EEEEEE; ", "CRAN", colspan = 3, width="65%")
      , tags$th(style = "text-align:middle; border: solid 2px #AAAAFF; background-color:#AAAAAA; ", width = "*", "GitHub")
      )
  , tags$tr(
      style = "align:top"
      , slider::slide(
          params$cran_libs
          , .after = 5
          , .step = 6
          , .f = \(x){ 
              sprintf("<li>%s</li>", x) |> HTML() |> 
                tags$ul() |> 
                tags$td(style = "text-align:middle; background-color:#AAAAAA; ")
              }
          , .complete = TRUE) |> 
          purrr::compact()
      , tags$td(style = "background-color:#EEEEEE; padding-right:20px; ", urls$git_libs)
      )
  ) |> tags$p()
```

## Data <br>Wrangling 

### Retrieve and Prepare Data {.tabset}

The data were retrieved via R package [httr](https://httr.r-lib.org) with some initial conversion to [data.table](https://rdatatable.gitlab.io/data.table/) objects.  

#### MDRP Data

```{r RETRIEVE_DATA_MDRP} 
# MDRP database data
if (!"api_data" %in% .cache$keys()){ 
  download_temp <- tempfile()
  
  as.character(urls$data) |> 
    stri_extract_all_regex("http.+csv", simplify = TRUE) |> 
    as.vector() |>
    download.file(destfile = download_temp) 
    
  .cache$set("api_data", { 
    read.csv(download_temp) |>
      as.data.table(na.rm = FALSE) 
  })
}

if (!"api_data" %in% ls()){ 
  makeActiveBinding("api_data", function(){ .cache$get("api_data") }, env = globalenv())
}

api_data |> dfSummary() |> view(method = "render")
```

Some of the values in date fields are empty strings and were replaced with "01/01/1900".  Additional formatting updates include the following:

- Convert field 'NDC' and fields ending in 'Code' to characters (numeral-encoded nominal values)
- Converting date fields to date content
- Replace '.' in field names with ' '

```{r}
if (!"api_data" %in% .cache$keys()){ 
  api_data %>%
    modify_at(ls(., pattern = "(NDC|Code)$"), as.character) %>%
    modify_at(ls(., pattern = "Date")
            , \(x) modify_if(x, \(i) (i == "")|rlang::is_empty(i), \(i) "01/01/1900") |> lubridate::mdy()
            ) %>%
  setnames(stri_replace_all_fixed(names(.), ".", " ")) |>
  (\(x) .cache$set(key = "api_data", value = x))()
}
```

#### Dictionary

```{r RETRIEVE_DATA_DICTIONARY}
if (!"api_dictionary" %in% .cache$keys()){ 
  .cache$set("api_dictionary", invisible( 
    as.character(urls$data) |> 
    stri_extract_all_regex("http.+pdf", simplify = TRUE) |> 
    as.vector() |>
    GET() |>
    content() |> 
    pdf_text()))
}  

.summary_labels <- {
  .pattern <- c("Pkg"
                , "Intro"
                , "COD Status"
                , "FDA Application Number"
                , "FDA Therapeutic Equivalence Code"
                );
  .replacement <- c("Package"
                , "Intro.+Date"
                , "Covered Outpatient Drug [(]COD[)] Status"
                , "FDA Application Number/OTC Monograph Number"
                , "TEC"
                );
  
  names(api_data) |>
    rlang::set_names() |>
    imap_chr(\(x, y){
      .out <- .cache$get("api_dictionary") |> 
        stri_extract_all_regex(
          sprintf(
            fmt = "(%s)[:]\n.+"
            , stri_replace_all_fixed(str = x, pattern = .pattern , replacement = .replacement, vectorize_all = FALSE)
            )
        , simplify = TRUE
        ) |>
        stats::na.omit() |>
        as.vector() |> paste(collapse = "\n")
      
      if (rlang::is_empty(.out)){ 
        y 
      } else{ 
        .out <- paste(.out, collapse = "\n")
        ifelse(stringi::stri_length(.out) > 50, paste0(stri_sub(.out, length = 50), " ..."), .out)
      }
    })
}

.tmp_obj <- api_data;

iwalk(.summary_labels, \(x, y){ 
  .tmp_obj <<- modify_at(.tmp_obj, y, \(i){ attr(i, "label") <- x; i }) 
})

.cache$set("api_data", .tmp_obj)
```

#### OpenFDA Data

```{r RETRIEVE_DATA_OPENFDA} 
suppressWarnings({ 
  # openFDA supplementary data
  if (!"open_fda_ndc" %in% .cache$keys()){
    json.file <- paste0(params$data_dir, "/drug-ndc-0001-of-0001.json");
    download.file <- tempfile();
    
    if (!file.exists(json.file)){ 
      tags$p(sprintf("Retrieve data from '%s'", urls$openFDA)) |> print()
      
      GET(urls$data$children |> stri_extract_first_regex("https.+json.zip"),
        write_disk(download.file, overwrite = TRUE));
      
      unzip(zipfile = download.file)
    }
        
    .cache$set("open_fda_ndc", { read_json(path = json.file) %$% {
      map(results, as.data.table) |> rbindlist(fill = TRUE) |>  
        setattr("metadata", meta)}
      })
  }
  if (!"openFDA_ndc" %in% ls()){ 
    makeActiveBinding("openFDA_ndc", function(){ .cache$get("open_fda_ndc")}, env = environment())
  }
})
```

#### NDC Format Inspection

NDC sequences come in a various formats, usually a `4-4-x`, `5-4-x`, or `5-3-x` sequence (each integer indicating string length).  Sometimes other formats arise, so normalizing all NDC sequences is a good idea, especially when there is a desire (or need) to join different data containing intersecting NDCs.


The following shows proportional representation of NDC formats in the *OpenFDA* and *MDRP* data, respectively:

```{r NDC_FORMATS, echo=FALSE} 
suppressWarnings({ list(
  `OpenFDA: NDC Formats` = openFDA_ndc[, unique(product_ndc)] |> 
      sort() |> 
      stri_split_fixed("-") |> 
      map_chr(\(x) stri_length(x) |> paste(collapse = "-")) |> 
      freduce(list(sort, table, as.data.table, \(x) setnames(x, c("NDC.Format", "N")))) 
  , `MDRP: NDC Formats` = (api_data %>% 
        setnames(stri_replace_all_fixed(names(.) |> tolower(), " ", "_"))
        )[, paste(stri_length(labeler_code), stri_length(product_code), sep = "-")] |>
        freduce(list(sort, table, as.data.table, \(x) setnames(x, c("NDC.Format", "N")) |> setkey(N))) |>
        define(
          NDC.Format = ifelse(ratio(N, type = "pareto", decimals = 6) < 0.1, "Other<br><sup>%s formats</sup>", NDC.Format) %>%
            modify_at(
              .at = which(grepl("Other", .))
              , .f = \(x) sprintf(x, sum(grepl("Other", .)))
              )
          , N = sum(N) ~ NDC.Format
          )
  ) |> 
  imap(\(x, y){
    plot_ly(  
      data = x
      , type = "pie"
      , labels = ~NDC.Format
      , values = ~N
      , hole = 0.6
      , width = 500
      , height = 450
      , rotation = ifelse(grepl("MDRP", y), 33, 0)
      , name = NULL
      , textinfo='label+percent'
      , insidetextorientation='radial'
      ) |>
      add_text(x = 0.5, y = 0.5
               , xref = "paper", yref = "paper"
               , text = ifelse(grepl("MDRP", y), "MDRP", "OpenFDA")
               , font = list(family = "Georgia", size = 22)) |>
      plotly::layout(
        xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE)
        , yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE)
        ) |>
      plotly::config(displayModeBar= FALSE) |>
      tags$td()
  }) |>
  tags$tr() |>
  tags$table()
});
```

The MDRP has many more NDC sequences due to truncation of leading zeroes.  Fortunately, an NDC sequence is a collection of code segments (present in the data) concatenated with a hyphen.  Knowing this, A function (`check_ndc_format()`) was created in order to derive conformed NDC segment sequences (using labeler and product codes) based on the OpenFDA sequences, allowing the MDRP and OpenFDA data to be joined later in the process.


```{r, CHECK_NDC_FORMAT_DEF} 
check_ndc_format <- \(lc, pc){ 
  pc <- modify_if(
          pc, \(i) stri_length(i) < 3
          , \(i) stri_pad_left(i, width = 3, pad = "0")
          )
  lc <- modify_if(
          lc
          , \(i) stri_length(i) < 4
          , \(i) stri_pad_left(i, width = ifelse(stri_length(pc) == 3, 5, 4), pad = "0")
          )
  paste(lc, pc, sep = "-")
}
```

#### Joined Data

The OpenFDA and MDRP data were joined using the conformed NDC sequence in the previous subsection to create `master_drug_data` sampled below (**Note**: due to the size of the data, the join operation takes some time which is why the result is disk-cached for later retrieval.  This caching approach is used for data retrieved or created during the data wrangling phase.): 

```{r JOIN_DRUG_DATA} 
if (!"master_drug_data" %in% .cache$keys()){
  .cache$set("master_drug_data", (\(x, i){
    x[i
      , on = "alt_ndc==product_ndc"
      , allow.cartesian = TRUE
      , `:=`(pharm_class = pharm_class
             , dea_schedule = dea_schedule
             , product_type = product_type
             , route = route
             , marketing_category = marketing_category
             )
      , by = .EACHI
      ][
      , `:=`(
        pharm_class = map_chr(pharm_class, \(x) unlist(x) %||% "~")
        , route = map_chr(route, \(x) unlist(x) %||% "~")
        )
      ]
    })(
      api_data %>% 
        setnames(stri_replace_all_fixed(names(.) |> tolower(), " ", "_")) %>% 
        .[, alt_ndc := map2_chr(labeler_code, product_code, check_ndc_format)]
      , openFDA_ndc
      ))
}
if (!"master_drug_data" %in% ls()){ 
  makeActiveBinding("master_drug_data", function(){ .cache$get("master_drug_data") }, env = globalenv());
}
```

```{r MASTER_DRUG_DATA_SAMPLE, echo=FALSE} 
define(
  master_drug_data
  , .SD[!duplicated(ndc)][sample(.N, min(c(.N, 3))), ndc:marketing_category] ~ route + pharm_class
  , filter(unique(.SD), pharm_class %in% sample(unique(pharm_class), 20))
  ) |>
  setorder(route, pharm_class, alt_ndc) %>%
  setcolorder(c("ndc", "alt_ndc", "fda_product_name", keep(names(.), \(x) grepl("date", x)))) %>%
  setnames(stri_split_fixed(names(.), "_", simplify = FALSE) |> map_chr(\(x) paste(x, collapse = "<br>"))) %>% 
  DT::datatable(
    escape = FALSE
    , caption = HTML("<h3 style = 'font-family:Georgia'>Sample of <code>master_drug_data</code></h3>")
    , rownames = FALSE
    , extensions = c("Responsive", "Scroller", "RowGroup")
    , options = list(
        dom = "<ti>"
        , deferRender = TRUE
        , scroller = TRUE
        , scrollY = 600
        , rowGroup = list(dataSrc = which(grepl("route|(pharm.+class)", names(.))) - 1)
        )
  )
```

## Temporal<br>Analysis {.tabset .tabet-fade}

`master_drug_data` is a great data set for constructing simple, time-based metrics.  Given the natural order of the types of events, it is easy to setup  event sequence metrics using package [`lubridate`](https://rdocumentation.org/packages/lubridate/versions/1.9.2). The metrics created are described below:

```{r NDC_EVENTS_METRICS_META, echo=FALSE} 
.ndc_events_meta <- rlang::set_names(
    c("Days between approval \nand market release"
        , "Days active on market"
        , "Days most-recently \nabsent from market")
    , c("days_to_market", "on_market_age", "days_market_absent")
    );

append(list(`Metric Name` = "Description"), .ndc_events_meta) |> 
  imap(\(x, y) 
    if (grepl("Metric", y)){ 
      tags$tr(
        tags$th(style = "background-color: #EEEEEE; padding:2px; ", y)
        , tags$th(style = "background-color: #EEEEEE; padding-left: 5px; ", x)
        )
      } else { 
      tags$tr(
        tags$td(style = "font-weight:bold; padding:2px; text-align:right; ", y)
        , tags$td(style = "padding-left: 5px; ", x)
        )
      }
    ) |> 
  tags$table() |>
  tags$p()
```

```{r NDC_EVENTS, echo = FALSE} 
if (!"ndc_events" %in% .cache$keys()){ 
  .tmp_obj <- define(
        master_drug_data
        , ~alt_ndc + fda_application_number + fda_approval_date + 
            market_date + termination_date + reactivation_date
        , days_to_market = market_date - fda_approval_date
        , on_market_age = 
            map2_dbl(ifelse(is.na(termination_date), today(), termination_date)
                     , reactivation_date, \(x, y) max(c(x, y), na.rm = TRUE)) -
            map2_dbl(ifelse(is.na(termination_date), market_date, termination_date)
                     , reactivation_date, \(x, y) max(c(x, y), na.rm = TRUE)) 
        , days_market_absent = 
            ifelse(is.na(reactivation_date), today(), reactivation_date) - 
            ifelse(is.na(termination_date), today(), termination_date)
        , unique(.SD)
        );
  
  iwalk(.ndc_events_meta, \(x, y){ .tmp_obj <<- modify_at(.tmp_obj, y, \(i){ setattr(i, "label", x) }) })

  .cache$set("ndc_events", .tmp_obj)
}

if (!"ndc_events" %in% ls()){ 
  makeActiveBinding("ndc_events", function(){ .cache$get("ndc_events") }, env = globalenv()) 
}
```

<hr>

Let us briefly explore `ndc_events` using `descr()` from the [summarytools](https://www.rdocumentation.org/packages/summarytools) package and `group.CI()` from [Rmisc](https://www.rdocumentation.org/packages/Rmisc):

### Take I 

```{r TAKE_I_VIZ} 
(\(x, i, by){
  i <- define(x[i, on = by, allow.cartesian = TRUE])
  
  imap(.ndc_events_meta, \(x, y){
    rlang::inject(descr(x = modify_at(i, y, \(j) as.numeric(j, units = "days")), var = !!rlang::sym(y), transpose = !TRUE)) |> 
      view(method = "render", table.classes = 'multi_stat'
           , custom.css = "markdown.css", report.title = " ") |> 
      tagList() |>
      tags$td()
  })
})(master_drug_data, ndc_events, c("alt_ndc", "fda_application_number")) |>
  tags$tr() |>
  tags$table()
```

### Take II 

As there should not be negative values, I reviewed the data and discovered that some values for each of the date columns were future-dated relative to "today": these dates were replaced with "today".  In additional, there were a small subset of observations having the FDA approval date **after** the listed market date: these were excluded.  The resulting object is captured in `ndc_events_clean` as an intermediate object: 


```{r TAKE_II_VIZ} 
ndc_events_clean <- define(
  ndc_events[(fda_approval_date <= market_date)]
  , days_to_market = market_date - fda_approval_date
  , on_market_age = 
      map2_dbl(
        termination_date
        , reactivation_date
        , \(x, y) ifelse(max(c(x, y)) == as.Date("1900-01-01"), today(), max(c(x, y)))
        ) - 
      map2_dbl(
        termination_date
        , market_date
        , \(x, y) max(c(x, y))
        )
  , days_market_absent = 
      ifelse(reactivation_date == as.Date("1900-01-01"), today(), reactivation_date) - 
      map2_dbl(
        termination_date
        , reactivation_date
        , \(x, y) ifelse(max(c(x, y)) == as.Date("1900-01-01"), today(), max(c(x, y)))
        )
  )

(\(x, i, by){
    i <- define(x[i, on = by, allow.cartesian = TRUE]) ;
    imap(.ndc_events_meta, \(x, y){
      rlang::inject(descr(x = modify_at(i, y, \(j) as.numeric(j, units = "days")), var = !!rlang::sym(y), transpose = !TRUE)) |> 
        view(method = "render", table.classes = 'multi_stat', custom.css = "markdown.css") |>
        tags$td()
    })
  })(master_drug_data, ndc_events_clean, c("alt_ndc", "fda_application_number", "market_date", "termination_date", "reactivation_date", "fda_approval_date")) |>
  tags$tr() |>
  tags$table()
```

### Take III {.tabset}

Better, but there are still some issues: 

#### Plot A

```{r TAKE_III_VIZ_A}
ndc_events_clean[, map(mget(c("termination_date", "reactivation_date")), \(x) today() - x)] |>
  as.list() |> 
  iwalk(\(x, y) na.omit(x) |> as.numeric()|> density() |> plot(main = y))

```

#### Plot B

`termination_date` and `reactivation_date` appeared to be the culprits, so I filtered the data for records where "today" is greater than the termination and reactivation dates and the termination date either is greater than the market date or the termination date is `1900-01-01`:

```{r TAKE_III_VIZ_B}
(\(x, i, by){
  .tmp_obj <<- define(
      x[i, on = by, allow.cartesian = TRUE]
      , unique(.SD[
          (today() >= termination_date) & 
          (today() >= reactivation_date) & 
          or(termination_date == as.Date("1900-01-01"), market_date < termination_date)
          ])
      , .SD[runif(length(alt_ndc)) <= 0.25]
      ) %T>% View()
  
  dfSummary(.tmp_obj) |> view(method = "render", custom.css = "markdown.css")
})(master_drug_data, ndc_events_clean, c("alt_ndc", "fda_application_number", "market_date", "termination_date", "reactivation_date", "fda_approval_date"))

```

### Take IV {.tabset}

Much better!  Combining the master drug data and event data (`master_drug_data` + `ndc_events_clean`), after some trial-and-error, I settled on the following showing the proportion of the margin of error to the mean grouped by drug route:

#### Plot A 

```{r TAKE_IV_VIZ_A} 
ndc_events_clean %<>% .[
          (today() >= termination_date) & 
          (today() >= reactivation_date) & 
          or(termination_date == as.Date("1900-01-01"), market_date < termination_date)
          ]

.temp_data <- {
  ndc_events_clean[
    , .(alt_ndc, fda_application_number, days_to_market, on_market_age, days_market_absent)
    ][
    master_drug_data
    , on = c("alt_ndc", "fda_application_number"), allow.cartesian = TRUE, nomatch = NULL
    ][, route_size := uniqueN(ndc), by = route] |> 
    unique() |>
    modify_at(c("days_to_market", "on_market_age", "days_market_absent"), \(x) as.difftime(x, units = "days"))
  } 
  

.plot_days_to_market <- {
  plot_ly(
    data = define(
      as.data.table(Rmisc::group.CI(days_to_market ~ route, data = .temp_data))
      , .SD[order(days_to_market.mean, route)]
      , days_text = sprintf("%.2f %s"
                , ifelse(days_to_market.mean > 365, days_to_market.mean/365, days_to_market.mean)
                , ifelse(days_to_market.mean > 365, "Years", "Days")
                )
      , .SD[.temp_data[, .(route, route_size)], on = "route", nomatch = 0] |> unique()
      )
    , x = ~log(days_to_market.mean, 7)
    , y = ~(days_to_market.upper - days_to_market.mean)/days_to_market.mean
    , split = ~route
    , size = ~20 * route_size/max(route_size)
    , hovertext = ~sprintf("<b>%s</b><br>Error Ratio: %.2f<br><br>%s", route, (days_to_market.upper - days_to_market.mean)/days_to_market.mean, days_text)
    , hoverinfo = "text"
    , width = 960
    , height = 800 + 0.9
    , type = "scatter"
    , mode = "markers"
    ) |>
  plotly::config(displayModeBar = FALSE) |>
    hide_colorbar() |>
    hide_legend() |> 
    layout(
      xaxis = list(
        title = list(text = "<span style='text-decoration:overline;'>X</span>: Days to Market (log<sub>7</sub> days)"
                     , font = list(family = "Georgia"), side = "top")
          , gridcolor = "#FFFFFF"
          )
      , yaxis = list(
          title = "<span style='text-decoration:overline;'>X</span><sub>Err</sub>/<span style='text-decoration:overline;'>X</span>"
          , gridcolor = "#FFFFFF"
          )
      , plot_bgcolor = "#EFEFEF"
      , margin = list(t = -0.5, b = -0.5)
      )
}

.plot_on_market_age <- {
  plot_ly(
    data = define(
      as.data.table(Rmisc::group.CI(on_market_age ~ route, data = .temp_data))
      , .SD[order(on_market_age.mean, route)]
      , days_text = sprintf("%.2f %s"
                             , ifelse(on_market_age.mean > 365, on_market_age.mean/365, on_market_age.mean)
                             , ifelse(on_market_age.mean > 365, "Years", "Days"))
      , .SD[.temp_data[, .(route, route_size)], on = "route", nomatch = 0] |> unique()
      )
    , x = ~log(on_market_age.mean, 7)
    , y = ~(on_market_age.upper - on_market_age.mean)/on_market_age.mean
    , split = ~route
    , size = ~30 * route_size/max(route_size)
    , hovertext = ~sprintf("<b>%s</b><br>Error Ratio: %.2f<br><br>%s", route, (on_market_age.upper - on_market_age.mean)/on_market_age.mean, days_text)
    , hoverinfo = "text"
    , width = 960
    , height = 800 + 0.9
    , type = "scatter"
    , mode = "markers"
    ) |>
  plotly::config(displayModeBar = FALSE) |>
    hide_colorbar() |>
    # hide_legend() |> 
    layout(
      xaxis = list(
        title = list(text = "<span style='text-decoration:overline;'>X</span>: Market Age (log<sub>7</sub> days)"
                     , font = list(family = "Georgia"), side = "top")
          , gridcolor = "#FFFFFF"
          )
      , yaxis = list(
          title = "<span style='text-decoration:overline;'>X</span><sub>Err</sub>/<span style='text-decoration:overline;'>X</span>"
          , gridcolor = "#FFFFFF"
          )
      , plot_bgcolor = "#EFEFEF"
      , margin = list(t = -0.5, b = -0.5)
      )
}

subplot(
  .plot_days_to_market
  , .plot_on_market_age
  , shareY = TRUE
  , titleX = TRUE
  , which_layout = 2
  ) |>
  config(mathjax = "cdn") |>
  layout(title = list(
      text = HTML("Z := (<span style='text-decoration:overline;'>X</span><sub>Err</sub>/<span style='text-decoration:overline;'>X</span> | Route)")
      , legend = list(font = list(size = 10))
      , font = list(family = "Georgia")
      ))

```

#### Plot B

```{r TAKE_IV_VIZ_B}

.plot_data <- (\(x, y){ 
    merge(
      setDT(plotly_data(x))[, .(days_to_market.mean, err_ratio = days_to_market.upper/days_to_market.mean - 1, route, days_text)]
      , setDT(plotly_data(y))[, .(on_market_age.mean, err_ratio = on_market_age.upper/on_market_age.mean - 1, route, days_text)]
      , by = 'route'
      , all.x = TRUE
      , all.y = TRUE
      )
  })(.plot_days_to_market, .plot_on_market_age) |>
    modify_at(c("err_ratio.x", "err_ratio.y"), \(x) ifelse(is.nan(x), 0, x)) |>
    modify_at("route", factor) %>%
    setnames(c("err_ratio.x", "err_ratio.y", "days_text.x", "days_text.y")
             , c("err_ratio.days_to_market", "err_ratio.on_market_age", "days_text.days_to_market", "days_text.on_market_age"))

.plot_days_to_market_age <- { 
  plot_ly(
    .plot_data
    , x = ~log(days_to_market.mean, 7)
    , y = ~log(on_market_age.mean, 7)
    , split = ~route
    , size = ~15 + 5*sqrt(err_ratio.days_to_market*err_ratio.on_market_age)
    , hovertext = ~sprintf("<b>%s</b><br>Error Ratio Product: %.4f<br><br>Days to Market: %s<br><br>On Market Days: %s"
                           , route
                           , err_ratio.days_to_market*err_ratio.on_market_age
                           , days_text.days_to_market, days_text.on_market_age
                           )
    , hoverinfo = "text"
    , width = 960
    , height = 800 + 0.9
    , type = "scatter"
    , mode = "markers"
    ) |>
  plotly::config(displayModeBar = FALSE) |>
    hide_colorbar() |>
    # hide_legend() |> 
    layout(
      xaxis = list(
        title = list(text = "<span style='text-decoration:overline;'>X</span>: Days to Market (log<sub>7</sub>)"
                      , font = list(family = "Georgia"))
          , gridcolor = "#FFFFFF"
        , type = "log")
      , yaxis = list(
          title = list(text = "<span style='text-decoration:overline;'>X</span>: On Market Age (log<sub>7</sub>)"
                       , font = list(family = "Georgia"))
          , gridcolor = "#FFFFFF"
          )
      , title = list(text = "Market Age vs. Days to Market by Drug Route<br><sup>Size ~ (Error Product)<sup>1/2</sup></sup>"
                     , font = list(family = "Georgia"))
      , plot_bgcolor = "#EFEFEF"
      , margin = list(t = -0.5, b = -0.5)
      )
}

.plot_days_to_market_age
```

